/**
 * @tekton/core - CSS Variables Generator
 * Generates CSS Variables from 3-layer token architecture
 * [SPEC-COMPONENT-001-A] [CSS-GENERATION]
 */

import type { ThemeWithTokens, ComponentTokens } from './tokens.js';
import { resolveToken } from './token-resolver.js';

// ============================================================================
// OKLCH Color Utilities (for v2.1 theme support)
// ============================================================================

interface OKLCHColor {
  l: number;
  c: number;
  h: number;
}

/**
 * Check if value is an OKLCH color object
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isOKLCHColor(value: any): value is OKLCHColor {
  return (
    value &&
    typeof value === 'object' &&
    typeof value.l === 'number' &&
    typeof value.c === 'number' &&
    typeof value.h === 'number'
  );
}

/**
 * Convert OKLCH color object to CSS string
 */
function oklchToCSS(color: OKLCHColor): string {
  const l = Math.max(0, Math.min(1, color.l));
  const c = Math.max(0, Math.min(0.5, color.c));
  const h = ((color.h % 360) + 360) % 360;
  return `oklch(${l} ${c} ${h})`;
}

// ============================================================================
// CSS Generation Functions
// ============================================================================

/**
 * Generates complete CSS with CSS Variables from theme tokens
 *
 * Produces CSS in the following structure:
 * ```css
 * :root {
 *   // Layer 1: Atomic Tokens
 *   --color-blue-500: #3b82f6;
 *   --spacing-4: 16px;
 *
 *   // Layer 2: Semantic Tokens
 *   --background-page: #f9fafb;
 *   --foreground-primary: #111827;
 *
 *   // Layer 3: Component Tokens
 *   --button-primary-background: #3b82f6;
 *   --input-focus-ring: #3b82f6;
 * }
 *
 * .dark {
 *   // Dark mode overrides
 *   --background-page: #111827;
 * }
 * ```
 *
 * @param theme - Theme with 3-layer token structure
 * @returns Generated CSS string with CSS Variables
 *
 * @example
 * ```typescript
 * const css = generateThemeCSS(myTheme);
 * // Write to file or inject into DOM
 * ```
 */
export function generateThemeCSS(theme: ThemeWithTokens): string {
  const { tokens } = theme;
  const lines: string[] = [
    `/* Generated by Tekton - Theme: ${theme.id} */`,
    `/* Do not edit manually - regenerate from theme definition */`,
    '',
    ':root {',
  ];

  // ========================================================================
  // Layer 1: Atomic Tokens
  // ========================================================================

  lines.push('  /* === Layer 1: Atomic Tokens === */');

  // Colors (v2.1 uses OKLCH objects, convert to CSS)
  if (tokens.atomic.color) {
    for (const [palette, shades] of Object.entries(tokens.atomic.color)) {
      if (shades && typeof shades === 'object') {
        for (const [shade, value] of Object.entries(shades)) {
          // Handle OKLCH color objects (v2.1) and string values (legacy)
          const cssValue = isOKLCHColor(value) ? oklchToCSS(value) : value;
          lines.push(`  --atomic-color-${palette}-${shade}: ${cssValue};`);
        }
      }
    }
  }

  // Spacing
  if (tokens.atomic.spacing) {
    lines.push('');
    for (const [size, value] of Object.entries(tokens.atomic.spacing)) {
      lines.push(`  --atomic-spacing-${size}: ${value};`);
    }
  }

  // Radius
  if (tokens.atomic.radius) {
    lines.push('');
    for (const [size, value] of Object.entries(tokens.atomic.radius)) {
      lines.push(`  --atomic-radius-${size}: ${value};`);
    }
  }

  // Typography (only if exists - not in v2.1 atomic tokens)
  if (tokens.atomic.typography) {
    lines.push('');
    for (const [name, props] of Object.entries(tokens.atomic.typography)) {
      if (props && typeof props === 'object') {
        lines.push(`  --atomic-typography-${name}-size: ${props.fontSize};`);
        lines.push(`  --atomic-typography-${name}-line-height: ${props.lineHeight};`);
        lines.push(`  --atomic-typography-${name}-weight: ${props.fontWeight};`);
      }
    }
  }

  // Shadow (only if exists - not in v2.1 atomic tokens)
  if (tokens.atomic.shadow) {
    lines.push('');
    for (const [name, value] of Object.entries(tokens.atomic.shadow)) {
      lines.push(`  --atomic-shadow-${name}: ${value};`);
    }
  }

  // Transition (optional)
  if (tokens.atomic.transition) {
    lines.push('');
    for (const [name, value] of Object.entries(tokens.atomic.transition)) {
      lines.push(`  --atomic-transition-${name}: ${value};`);
    }
  }

  // ========================================================================
  // Layer 2: Semantic Tokens
  // ========================================================================

  lines.push('');
  lines.push('  /* === Layer 2: Semantic Tokens === */');

  if (tokens.semantic) {
    for (const [category, values] of Object.entries(tokens.semantic)) {
      if (values && typeof values === 'object') {
        generateSemanticTokens(category, values, tokens, lines);
      }
    }
  }

  // ========================================================================
  // Layer 3: Component Tokens
  // ========================================================================

  lines.push('');
  lines.push('  /* === Layer 3: Component Tokens === */');

  // Component tokens are optional in v2.1
  if (tokens.component) {
    lines.push(...generateComponentCSS(tokens.component, tokens));
  }

  lines.push('}');

  // ========================================================================
  // Dark Mode
  // ========================================================================

  if (theme.darkMode) {
    lines.push('');
    lines.push('.dark {');
    lines.push('  /* === Dark Mode Overrides === */');

    // Dark mode semantic tokens
    if (theme.darkMode.tokens.semantic && Object.keys(theme.darkMode.tokens.semantic).length > 0) {
      for (const [category, values] of Object.entries(theme.darkMode.tokens.semantic)) {
        if (values && typeof values === 'object') {
          for (const [name, ref] of Object.entries(values as Record<string, string>)) {
            if (ref) {
              // Merge dark mode semantic tokens with original for resolution
              const darkModeTokens = {
                ...tokens,
                semantic: {
                  ...tokens.semantic,
                  [category]: {
                    ...(tokens.semantic[category as keyof typeof tokens.semantic] as Record<
                      string,
                      string
                    >),
                    ...(values as Record<string, string>),
                  },
                },
              };
              const resolved = resolveToken(ref, darkModeTokens);
              lines.push(`  --${category}-${name}: ${resolved};`);
            }
          }
        }
      }
    }

    // Dark mode component tokens
    if (
      theme.darkMode.tokens.component &&
      Object.keys(theme.darkMode.tokens.component).length > 0
    ) {
      lines.push(
        ...generateComponentCSS(theme.darkMode.tokens.component as ComponentTokens, tokens)
      );
    }

    lines.push('}');
  }

  return lines.join('\n');
}

/**
 * Recursively generates CSS variables for semantic tokens
 * Handles nested structures like background.surface.subtle
 *
 * @internal
 */
function generateSemanticTokens(
  prefix: string,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  values: any,
  tokens: ThemeWithTokens['tokens'],
  lines: string[]
): void {
  for (const [key, value] of Object.entries(values)) {
    const varName = `--atomic-semantic-${prefix}-${key}`;

    if (typeof value === 'string') {
      // Resolve token reference (e.g., "atomic.color.neutral.50")
      const resolved = resolveTokenWithFallback(value, tokens);
      lines.push(`  ${varName}: ${resolved};`);
    } else if (value && typeof value === 'object') {
      // Recursively handle nested objects
      generateSemanticTokens(`${prefix}-${key}`, value, tokens, lines);
    }
  }
}

/**
 * Resolve token reference with fallback for v2.1 references
 * v2.1 uses "atomic.color.neutral.50" format
 * Returns CSS variable fallback if token not found (graceful degradation)
 *
 * @internal
 */
function resolveTokenWithFallback(ref: string, tokens: ThemeWithTokens['tokens']): string {
  // Check for direct CSS values first (not token references)
  // Direct values: hex colors (#fff, #ffffff), CSS units (10px, 1rem), rgb/hsl functions
  if (
    ref.startsWith('#') ||
    ref.startsWith('rgb') ||
    ref.startsWith('hsl') ||
    ref.startsWith('oklch') ||
    /^\d+(\.\d+)?(px|rem|em|%|vh|vw|ms|s)$/.test(ref)
  ) {
    return ref;
  }

  // First try standard resolution (with error handling)
  try {
    const resolved = resolveToken(ref, tokens);
    if (resolved !== ref) {
      return resolved;
    }
  } catch {
    // Ignore errors from resolveToken, we'll handle fallback below
  }

  // For v2.1 references like "atomic.color.neutral.50", resolve manually
  const parts = ref.split('.');
  if (parts[0] === 'atomic' && parts[1] === 'color' && parts.length >= 4) {
    const palette = parts[2];
    const shade = parts.slice(3).join('.');
    const colorValue = tokens.atomic?.color?.[palette]?.[shade];
    if (colorValue) {
      return isOKLCHColor(colorValue) ? oklchToCSS(colorValue) : colorValue;
    }
  }

  // Return original ref as CSS var reference (graceful fallback)
  return `var(--atomic-${ref.replace(/\./g, '-')})`;
}

/**
 * Generates CSS variables for component tokens
 *
 * Flattens nested component token structure into CSS variable declarations
 *
 * @param componentTokens - Component token structure
 * @param tokens - Full token structure for resolution
 * @returns Array of CSS variable declaration lines
 *
 * @internal
 */
function generateComponentCSS(
  componentTokens: ComponentTokens,
  tokens: ThemeWithTokens['tokens']
): string[] {
  const lines: string[] = [];

  for (const [component, variants] of Object.entries(componentTokens)) {
    if (typeof variants === 'object' && variants !== null) {
      // Check if this is a direct component (like input, card) or has variants (like button.primary)
      const isDirectComponent = hasDirectProperties(variants);

      if (isDirectComponent) {
        // Direct component (e.g., input, card)
        flattenTokens(variants, component, tokens, lines);
      } else {
        // Component with variants (e.g., button.primary)
        for (const [variant, props] of Object.entries(variants)) {
          if (typeof props === 'object' && props !== null) {
            flattenTokens(props, `${component}-${variant}`, tokens, lines);
          }
        }
      }
    }
  }

  return lines;
}

/**
 * Checks if object has direct properties (non-object values)
 *
 * @param obj - Object to check
 * @returns True if object contains string values (not just nested objects)
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function hasDirectProperties(obj: any): boolean {
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }

  for (const value of Object.values(obj)) {
    if (typeof value === 'string') {
      return true;
    }
  }

  return false;
}

/**
 * Recursively flattens nested token object into CSS variable declarations
 *
 * Converts nested structure like:
 * ```
 * { hover: { background: 'value' } }
 * ```
 *
 * Into CSS variables:
 * ```
 * --prefix-hover-background: resolved-value;
 * ```
 *
 * @param obj - Token object to flatten
 * @param prefix - CSS variable name prefix
 * @param tokens - Full token structure for resolution
 * @param lines - Array to append CSS lines to
 *
 * @internal
 */
function flattenTokens(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  obj: any,
  prefix: string,
  tokens: ThemeWithTokens['tokens'],
  lines: string[]
): void {
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'object' && value !== null) {
      // Recurse for nested objects
      flattenTokens(value, `${prefix}-${key}`, tokens, lines);
    } else if (typeof value === 'string') {
      // Resolve and output CSS variable
      const resolved = resolveToken(value, tokens);
      lines.push(`  --${prefix}-${key}: ${resolved};`);
    }
  }
}
