/**
 * @tekton/core - CSS Variables Generator
 * Generates CSS Variables from 3-layer token architecture
 * [SPEC-COMPONENT-001-A] [CSS-GENERATION]
 */

import type { ThemeWithTokens, ComponentTokens } from './tokens.js';
import { resolveToken } from './token-resolver.js';

// ============================================================================
// CSS Generation Functions
// ============================================================================

/**
 * Generates complete CSS with CSS Variables from theme tokens
 *
 * Produces CSS in the following structure:
 * ```css
 * :root {
 *   // Layer 1: Atomic Tokens
 *   --color-blue-500: #3b82f6;
 *   --spacing-4: 16px;
 *
 *   // Layer 2: Semantic Tokens
 *   --background-page: #f9fafb;
 *   --foreground-primary: #111827;
 *
 *   // Layer 3: Component Tokens
 *   --button-primary-background: #3b82f6;
 *   --input-focus-ring: #3b82f6;
 * }
 *
 * .dark {
 *   // Dark mode overrides
 *   --background-page: #111827;
 * }
 * ```
 *
 * @param theme - Theme with 3-layer token structure
 * @returns Generated CSS string with CSS Variables
 *
 * @example
 * ```typescript
 * const css = generateThemeCSS(myTheme);
 * // Write to file or inject into DOM
 * ```
 */
export function generateThemeCSS(theme: ThemeWithTokens): string {
  const { tokens } = theme;
  const lines: string[] = [
    `/* Generated by Tekton - Theme: ${theme.id} */`,
    `/* Do not edit manually - regenerate from theme definition */`,
    '',
    ':root {',
  ];

  // ========================================================================
  // Layer 1: Atomic Tokens
  // ========================================================================

  lines.push('  /* === Layer 1: Atomic Tokens === */');

  // Colors
  for (const [palette, shades] of Object.entries(tokens.atomic.color)) {
    for (const [shade, value] of Object.entries(shades)) {
      lines.push(`  --color-${palette}-${shade}: ${value};`);
    }
  }

  // Spacing
  lines.push('');
  for (const [size, value] of Object.entries(tokens.atomic.spacing)) {
    lines.push(`  --spacing-${size}: ${value};`);
  }

  // Radius
  lines.push('');
  for (const [size, value] of Object.entries(tokens.atomic.radius)) {
    lines.push(`  --radius-${size}: ${value};`);
  }

  // Typography
  lines.push('');
  for (const [name, props] of Object.entries(tokens.atomic.typography)) {
    lines.push(`  --typography-${name}-size: ${props.fontSize};`);
    lines.push(`  --typography-${name}-line-height: ${props.lineHeight};`);
    lines.push(`  --typography-${name}-weight: ${props.fontWeight};`);
  }

  // Shadow
  lines.push('');
  for (const [name, value] of Object.entries(tokens.atomic.shadow)) {
    lines.push(`  --shadow-${name}: ${value};`);
  }

  // Transition (optional)
  if (tokens.atomic.transition) {
    lines.push('');
    for (const [name, value] of Object.entries(tokens.atomic.transition)) {
      lines.push(`  --transition-${name}: ${value};`);
    }
  }

  // ========================================================================
  // Layer 2: Semantic Tokens
  // ========================================================================

  lines.push('');
  lines.push('  /* === Layer 2: Semantic Tokens === */');

  for (const [category, values] of Object.entries(tokens.semantic)) {
    for (const [name, ref] of Object.entries(values as Record<string, string>)) {
      const resolved = resolveToken(ref, tokens);
      lines.push(`  --${category}-${name}: ${resolved};`);
    }
  }

  // ========================================================================
  // Layer 3: Component Tokens
  // ========================================================================

  lines.push('');
  lines.push('  /* === Layer 3: Component Tokens === */');

  lines.push(...generateComponentCSS(tokens.component, tokens));

  lines.push('}');

  // ========================================================================
  // Dark Mode
  // ========================================================================

  if (theme.darkMode) {
    lines.push('');
    lines.push('.dark {');
    lines.push('  /* === Dark Mode Overrides === */');

    // Dark mode semantic tokens
    if (theme.darkMode.tokens.semantic && Object.keys(theme.darkMode.tokens.semantic).length > 0) {
      for (const [category, values] of Object.entries(theme.darkMode.tokens.semantic)) {
        if (values && typeof values === 'object') {
          for (const [name, ref] of Object.entries(values as Record<string, string>)) {
            if (ref) {
              // Merge dark mode semantic tokens with original for resolution
              const darkModeTokens = {
                ...tokens,
                semantic: {
                  ...tokens.semantic,
                  [category]: {
                    ...(tokens.semantic[category as keyof typeof tokens.semantic] as Record<
                      string,
                      string
                    >),
                    ...(values as Record<string, string>),
                  },
                },
              };
              const resolved = resolveToken(ref, darkModeTokens);
              lines.push(`  --${category}-${name}: ${resolved};`);
            }
          }
        }
      }
    }

    // Dark mode component tokens
    if (
      theme.darkMode.tokens.component &&
      Object.keys(theme.darkMode.tokens.component).length > 0
    ) {
      lines.push(
        ...generateComponentCSS(theme.darkMode.tokens.component as ComponentTokens, tokens)
      );
    }

    lines.push('}');
  }

  return lines.join('\n');
}

/**
 * Generates CSS variables for component tokens
 *
 * Flattens nested component token structure into CSS variable declarations
 *
 * @param componentTokens - Component token structure
 * @param tokens - Full token structure for resolution
 * @returns Array of CSS variable declaration lines
 *
 * @internal
 */
function generateComponentCSS(
  componentTokens: ComponentTokens,
  tokens: ThemeWithTokens['tokens']
): string[] {
  const lines: string[] = [];

  for (const [component, variants] of Object.entries(componentTokens)) {
    if (typeof variants === 'object' && variants !== null) {
      // Check if this is a direct component (like input, card) or has variants (like button.primary)
      const isDirectComponent = hasDirectProperties(variants);

      if (isDirectComponent) {
        // Direct component (e.g., input, card)
        flattenTokens(variants, component, tokens, lines);
      } else {
        // Component with variants (e.g., button.primary)
        for (const [variant, props] of Object.entries(variants)) {
          if (typeof props === 'object' && props !== null) {
            flattenTokens(props, `${component}-${variant}`, tokens, lines);
          }
        }
      }
    }
  }

  return lines;
}

/**
 * Checks if object has direct properties (non-object values)
 *
 * @param obj - Object to check
 * @returns True if object contains string values (not just nested objects)
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function hasDirectProperties(obj: any): boolean {
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }

  for (const value of Object.values(obj)) {
    if (typeof value === 'string') {
      return true;
    }
  }

  return false;
}

/**
 * Recursively flattens nested token object into CSS variable declarations
 *
 * Converts nested structure like:
 * ```
 * { hover: { background: 'value' } }
 * ```
 *
 * Into CSS variables:
 * ```
 * --prefix-hover-background: resolved-value;
 * ```
 *
 * @param obj - Token object to flatten
 * @param prefix - CSS variable name prefix
 * @param tokens - Full token structure for resolution
 * @param lines - Array to append CSS lines to
 *
 * @internal
 */
function flattenTokens(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  obj: any,
  prefix: string,
  tokens: ThemeWithTokens['tokens'],
  lines: string[]
): void {
  for (const [key, value] of Object.entries(obj)) {
    if (typeof value === 'object' && value !== null) {
      // Recurse for nested objects
      flattenTokens(value, `${prefix}-${key}`, tokens, lines);
    } else if (typeof value === 'string') {
      // Resolve and output CSS variable
      const resolved = resolveToken(value, tokens);
      lines.push(`  --${prefix}-${key}: ${resolved};`);
    }
  }
}
