/**
 * Component Generator
 *
 * Generates individual React component files from archetype data.
 * Each component gets:
 * - ComponentName.tsx - React functional component
 * - ComponentName.css - Styles using CSS variables
 */

import fs from 'fs-extra';
import * as path from 'path';
import type { CompleteArchetype } from '../clients/mcp-client.js';
import {
  transformArchetypeToComponent,
  transformArchetypesToComponents,
  type GeneratedComponent,
  type TransformOptions,
} from './code-template-engine.js';

/**
 * Component generation options
 */
export interface ComponentGenerationOptions {
  outputDir: string;
  archetypes?: Map<string, CompleteArchetype>;
  components: string[];
  prefix?: string;
  overwrite?: boolean;
}

/**
 * Component generation result
 */
export interface ComponentGenerationResult {
  success: boolean;
  generated: GeneratedFile[];
  skipped: string[];
  errors: ComponentError[];
}

/**
 * Generated file info
 */
export interface GeneratedFile {
  component: string;
  tsx: string;
  css: string;
}

/**
 * Component error info
 */
export interface ComponentError {
  component: string;
  error: string;
}

/**
 * Generate barrel export file (index.ts)
 */
export function generateBarrelExport(componentNames: string[]): string {
  const lines: string[] = [];
  lines.push('/**');
  lines.push(' * Component Exports');
  lines.push(' * Generated by Tekton CLI');
  lines.push(' */');
  lines.push('');

  for (const name of componentNames) {
    lines.push(`export { ${name} } from './${name}.js';`);
  }

  lines.push('');
  return lines.join('\n');
}

/**
 * Generate component files from archetypes
 */
export async function generateComponentFiles(
  options: ComponentGenerationOptions
): Promise<ComponentGenerationResult> {
  const result: ComponentGenerationResult = {
    success: true,
    generated: [],
    skipped: [],
    errors: [],
  };

  const transformOptions: TransformOptions = {
    prefix: options.prefix || 'tekton',
    includeComments: true,
    useTypeScript: true,
  };

  // Transform archetypes to components
  const archetypes = options.archetypes || new Map<string, CompleteArchetype>();
  const generatedComponents = transformArchetypesToComponents(
    archetypes,
    options.components,
    transformOptions
  );

  // Write component files
  for (const component of generatedComponents) {
    try {
      const tsxPath = path.join(options.outputDir, `${component.name}.tsx`);
      const cssPath = path.join(options.outputDir, `${component.name}.css`);

      // Check if files exist
      const tsxExists = await fs.pathExists(tsxPath);
      const cssExists = await fs.pathExists(cssPath);

      if ((tsxExists || cssExists) && !options.overwrite) {
        result.skipped.push(component.name);
        continue;
      }

      // Write files
      await fs.writeFile(tsxPath, component.tsx, 'utf-8');
      await fs.writeFile(cssPath, component.css, 'utf-8');

      result.generated.push({
        component: component.name,
        tsx: tsxPath,
        css: cssPath,
      });
    } catch (error) {
      result.errors.push({
        component: component.name,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
      result.success = false;
    }
  }

  // Generate barrel export
  try {
    const indexPath = path.join(options.outputDir, 'index.ts');
    const indexContent = generateBarrelExport(options.components);
    await fs.writeFile(indexPath, indexContent, 'utf-8');
  } catch (error) {
    result.errors.push({
      component: 'index.ts',
      error: error instanceof Error ? error.message : 'Failed to generate barrel export',
    });
  }

  return result;
}

/**
 * Generate a single component
 */
export async function generateSingleComponent(
  componentName: string,
  outputDir: string,
  archetype?: CompleteArchetype,
  options?: Partial<ComponentGenerationOptions>
): Promise<GeneratedFile | null> {
  const transformOptions: TransformOptions = {
    prefix: options?.prefix || 'tekton',
    includeComments: true,
    useTypeScript: true,
  };

  const component = transformArchetypeToComponent(
    componentName,
    archetype || null,
    transformOptions
  );

  const tsxPath = path.join(outputDir, `${component.name}.tsx`);
  const cssPath = path.join(outputDir, `${component.name}.css`);

  try {
    await fs.ensureDir(outputDir);
    await fs.writeFile(tsxPath, component.tsx, 'utf-8');
    await fs.writeFile(cssPath, component.css, 'utf-8');

    return {
      component: component.name,
      tsx: tsxPath,
      css: cssPath,
    };
  } catch {
    return null;
  }
}

/**
 * Get component hook name mapping
 */
export function getHookNameForComponent(componentName: string): string {
  const mapping: Record<string, string> = {
    Button: 'useButton',
    Input: 'useTextField',
    TextField: 'useTextField',
    Select: 'useSelect',
    Checkbox: 'useCheckbox',
    Switch: 'useSwitch',
    Toggle: 'useToggleButton',
    Radio: 'useRadioGroup',
    Slider: 'useSlider',
    Card: 'useCard',
    Dialog: 'useDialog',
    Modal: 'useDialog',
    Menu: 'useMenu',
    DropdownMenu: 'useDropdownMenu',
    Dropdown: 'useDropdownMenu',
    Tabs: 'useTabs',
    Table: 'useTable',
    DataTable: 'useTable',
    Tooltip: 'useTooltip',
    Popover: 'usePopover',
    Toast: 'useToast',
    Alert: 'useAlert',
    Badge: 'useBadge',
    Avatar: 'useAvatar',
    Progress: 'useProgressBar',
    ProgressBar: 'useProgressBar',
    Accordion: 'useAccordion',
    Breadcrumb: 'useBreadcrumbs',
    Pagination: 'usePagination',
    Calendar: 'useCalendar',
    DatePicker: 'useDatePicker',
    Form: 'useForm',
    Chart: 'useChart',
    Stat: 'useStat',
    StatCard: 'useStat',
  };

  return mapping[componentName] || `use${componentName}`;
}

/**
 * Check if archetype exists for component
 */
export function hasArchetypeForComponent(
  componentName: string,
  archetypes: Map<string, CompleteArchetype>
): boolean {
  const hookName = getHookNameForComponent(componentName);
  return archetypes.has(hookName);
}

/**
 * Get archetype for component
 */
export function getArchetypeForComponent(
  componentName: string,
  archetypes: Map<string, CompleteArchetype>
): CompleteArchetype | null {
  const hookName = getHookNameForComponent(componentName);
  return archetypes.get(hookName) || null;
}

/**
 * Generate component preview (for dry-run)
 */
export function previewComponent(
  componentName: string,
  archetype?: CompleteArchetype,
  options?: TransformOptions
): GeneratedComponent {
  return transformArchetypeToComponent(
    componentName,
    archetype || null,
    options || {}
  );
}

/**
 * Get list of supported component types
 */
export function getSupportedComponentTypes(): string[] {
  return [
    'Button',
    'Input',
    'Card',
    'Badge',
    'Avatar',
    'Alert',
    'Dialog',
    'Table',
    'Stat',
    'Chart',
    'Progress',
    'Tooltip',
    'Tabs',
    'Menu',
    'Select',
    'Checkbox',
    'Switch',
    'Slider',
    'Accordion',
    'Pagination',
  ];
}

/**
 * Validate component names
 */
export function validateComponentNames(names: string[]): {
  valid: string[];
  invalid: string[];
} {
  const supported = new Set(getSupportedComponentTypes());
  const valid: string[] = [];
  const invalid: string[] = [];

  for (const name of names) {
    // Accept supported components or any PascalCase name
    if (supported.has(name) || /^[A-Z][a-zA-Z0-9]*$/.test(name)) {
      valid.push(name);
    } else {
      invalid.push(name);
    }
  }

  return { valid, invalid };
}
