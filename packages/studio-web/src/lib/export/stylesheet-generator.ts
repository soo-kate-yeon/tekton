/**
 * React Native StyleSheet Generator
 * Export tokens as StyleSheet.create() compatible object
 */

import type { SemanticToken, CompositionToken, ColorToken } from '@tekton/token-contract';

export interface StyleSheetExportOptions {
  semantic: SemanticToken;
  composition?: CompositionToken;
  includeTypes?: boolean;
}

/**
 * Convert OKLCH color token to CSS string
 */
function colorToString(color: ColorToken | string): string {
  if (typeof color === 'string') {
    return color;
  }
  return `oklch(${color.l} ${color.c} ${color.h})`;
}

/**
 * Generate React Native StyleSheet export
 */
export function generateStyleSheetExport({
  semantic,
  composition,
  includeTypes = true,
}: StyleSheetExportOptions): string {
  const lines: string[] = [];

  // Add header comment
  lines.push('/**');
  lines.push(' * Design Tokens - Generated by Tekton Studio');
  lines.push(' * For use with React Native StyleSheet');
  lines.push(' * @generated');
  lines.push(' */');
  lines.push('');

  // Import statement
  lines.push("import { StyleSheet } from 'react-native';");
  lines.push('');

  // Generate color constants
  lines.push('// Color Tokens');
  lines.push('export const colors = {');

  for (const [tokenName, scale] of Object.entries(semantic)) {
    if (scale && typeof scale === 'object') {
      lines.push(`  ${tokenName}: {`);
      for (const [step, value] of Object.entries(scale)) {
        const colorStr = colorToString(value);
        lines.push(`    '${step}': '${colorStr}',`);
      }
      lines.push('  },');
    }
  }

  lines.push('};');
  lines.push('');

  // Generate composition tokens
  if (composition) {
    lines.push('// Composition Tokens');
    lines.push('export const tokens = {');

    if (composition.border) {
      lines.push('  border: {');
      for (const [key, value] of Object.entries(composition.border)) {
        const val = key === 'color' ? colorToString(value as ColorToken) : String(value);
        lines.push(`    ${key}: '${val}',`);
      }
      lines.push('  },');
    }

    if (composition.spacing) {
      lines.push('  spacing: {');
      for (const [key, value] of Object.entries(composition.spacing)) {
        lines.push(`    ${key}: '${value}',`);
      }
      lines.push('  },');
    }

    if (composition.typography) {
      lines.push('  typography: {');
      for (const [key, value] of Object.entries(composition.typography)) {
        const val = typeof value === 'number' ? value : `'${value}'`;
        lines.push(`    ${key}: ${val},`);
      }
      lines.push('  },');
    }

    if (composition.shadow) {
      lines.push('  shadow: {');
      for (const [key, value] of Object.entries(composition.shadow)) {
        const val = key === 'color' ? colorToString(value as ColorToken) : String(value);
        lines.push(`    ${key}: '${val}',`);
      }
      lines.push('  },');
    }

    lines.push('};');
    lines.push('');
  }

  // Generate base styles
  lines.push('// Base Styles');
  lines.push('export const styles = StyleSheet.create({');
  lines.push('  // Primary Button');
  lines.push('  buttonPrimary: {');
  lines.push("    backgroundColor: colors.primary['500'],");
  lines.push("    borderRadius: parseInt(tokens?.border?.radius || '8', 10),");
  lines.push('    paddingVertical: 12,');
  lines.push('    paddingHorizontal: 16,');
  lines.push('  },');
  lines.push('  // Text Styles');
  lines.push('  textPrimary: {');
  lines.push("    color: colors.neutral['900'],");
  lines.push('    fontSize: 16,');
  lines.push('    fontWeight: \'400\',');
  lines.push('  },');
  lines.push('  textSecondary: {');
  lines.push("    color: colors.neutral['600'],");
  lines.push('    fontSize: 14,');
  lines.push('    fontWeight: \'400\',');
  lines.push('  },');
  lines.push('});');
  lines.push('');

  // Add TypeScript types if requested
  if (includeTypes) {
    lines.push('// Type Definitions');
    lines.push('export type ColorScale = typeof colors.primary;');
    lines.push('export type ColorName = keyof typeof colors;');
    lines.push('export type ColorStep = keyof ColorScale;');
  }

  return lines.join('\n');
}

/**
 * Generate minimal color-only export
 */
export function generateColorOnlyExport(semantic: SemanticToken): string {
  const lines: string[] = [];

  lines.push('// Color Constants');
  lines.push('export const colors = {');

  for (const [tokenName, scale] of Object.entries(semantic)) {
    if (scale && typeof scale === 'object') {
      lines.push(`  ${tokenName}: {`);
      for (const [step, value] of Object.entries(scale)) {
        const colorStr = colorToString(value);
        lines.push(`    '${step}': '${colorStr}',`);
      }
      lines.push(`  } as const,`);
    }
  }

  lines.push('} as const;');

  return lines.join('\n');
}
