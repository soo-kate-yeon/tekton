/**
 * CSS Generator for MCP Server (v2.1)
 * SPEC-COMPONENT-001-D: Hybrid Export System
 *
 * Generates CSS Variables from ThemeV2 (v2.1 theme schema)
 */

import { loadTheme, oklchToCSS, type ThemeV2 } from '@tekton/core';

/**
 * CSS 생성 결과 타입
 */
export interface CSSGenerationResult {
  success: boolean;
  css?: string;
  error?: string;
}

/**
 * ThemeV2 (v2.1)에서 CSS Variables 생성
 *
 * @param theme - ThemeV2 객체
 * @returns CSS 생성 결과
 *
 * @example
 * ```typescript
 * const theme = loadTheme('atlantic-magazine-v1');
 * if (theme) {
 *   const result = generateCSS(theme);
 *   if (result.success) {
 *     console.log(result.css);
 *   }
 * }
 * ```
 */
export function generateCSS(theme: ThemeV2): CSSGenerationResult {
  try {
    const lines: string[] = [
      `/* Generated by Tekton - Theme: ${theme.id} */`,
      `/* Schema Version: ${theme.schemaVersion} */`,
      '',
      ':root {',
    ];

    // ========================================================================
    // Layer 1: Atomic Tokens
    // ========================================================================
    lines.push('  /* === Layer 1: Atomic Tokens === */');

    // Colors (OKLCH format)
    const { color } = theme.tokens.atomic;
    if (color.brand) {
      for (const [shade, oklch] of Object.entries(color.brand)) {
        lines.push(`  --color-brand-${shade}: ${oklchToCSS(oklch)};`);
      }
    }
    if (color.neutral) {
      for (const [shade, oklch] of Object.entries(color.neutral)) {
        lines.push(`  --color-neutral-${shade}: ${oklchToCSS(oklch)};`);
      }
    }
    if (color.accent) {
      for (const [shade, oklch] of Object.entries(color.accent)) {
        lines.push(`  --color-accent-${shade}: ${oklchToCSS(oklch)};`);
      }
    }
    if (color.success) {
      lines.push(`  --color-success: ${oklchToCSS(color.success)};`);
    }
    if (color.warning) {
      lines.push(`  --color-warning: ${oklchToCSS(color.warning)};`);
    }
    if (color.error) {
      lines.push(`  --color-error: ${oklchToCSS(color.error)};`);
    }
    if (color.info) {
      lines.push(`  --color-info: ${oklchToCSS(color.info)};`);
    }

    // Spacing
    lines.push('');
    for (const [size, value] of Object.entries(theme.tokens.atomic.spacing)) {
      lines.push(`  --spacing-${size}: ${value};`);
    }

    // Radius
    lines.push('');
    for (const [size, value] of Object.entries(theme.tokens.atomic.radius)) {
      lines.push(`  --radius-${size}: ${value};`);
    }

    // ========================================================================
    // Typography
    // ========================================================================
    lines.push('');
    lines.push('  /* === Typography === */');
    const { typography } = theme;
    if (typography.fontFamily) {
      for (const [name, value] of Object.entries(typography.fontFamily)) {
        lines.push(`  --font-family-${name}: ${value};`);
      }
    }
    if (typography.fontSize) {
      for (const [name, value] of Object.entries(typography.fontSize)) {
        lines.push(`  --font-size-${name}: ${value};`);
      }
    }
    if (typography.fontWeight) {
      for (const [name, value] of Object.entries(typography.fontWeight)) {
        lines.push(`  --font-weight-${name}: ${value};`);
      }
    }
    if (typography.lineHeight) {
      for (const [name, value] of Object.entries(typography.lineHeight)) {
        lines.push(`  --line-height-${name}: ${value};`);
      }
    }
    if (typography.letterSpacing) {
      for (const [name, value] of Object.entries(typography.letterSpacing)) {
        lines.push(`  --letter-spacing-${name}: ${value};`);
      }
    }

    // ========================================================================
    // Border
    // ========================================================================
    lines.push('');
    lines.push('  /* === Border === */');
    const { border } = theme;
    if (border.width) {
      for (const [name, value] of Object.entries(border.width)) {
        lines.push(`  --border-width-${name}: ${value};`);
      }
    }
    if (border.radius) {
      for (const [name, value] of Object.entries(border.radius)) {
        lines.push(`  --border-radius-${name}: ${value};`);
      }
    }

    // ========================================================================
    // Elevation
    // ========================================================================
    lines.push('');
    lines.push('  /* === Elevation === */');
    const { elevation } = theme;
    if (elevation.level) {
      for (const [name, value] of Object.entries(elevation.level)) {
        lines.push(`  --elevation-${name}: ${value};`);
      }
    }

    // ========================================================================
    // Motion
    // ========================================================================
    lines.push('');
    lines.push('  /* === Motion === */');
    const { motion } = theme;
    if (motion.duration) {
      for (const [name, value] of Object.entries(motion.duration)) {
        lines.push(`  --duration-${name}: ${value};`);
      }
    }
    if (motion.easing) {
      for (const [name, value] of Object.entries(motion.easing)) {
        lines.push(`  --easing-${name}: ${value};`);
      }
    }

    // ========================================================================
    // State Layer
    // ========================================================================
    lines.push('');
    lines.push('  /* === State Layer === */');
    const { stateLayer } = theme;
    if (stateLayer.hover?.opacity !== undefined) {
      lines.push(`  --state-hover-opacity: ${stateLayer.hover.opacity};`);
    }
    if (stateLayer.pressed?.opacity !== undefined) {
      lines.push(`  --state-pressed-opacity: ${stateLayer.pressed.opacity};`);
    }
    if (stateLayer.focus?.opacity !== undefined) {
      lines.push(`  --state-focus-opacity: ${stateLayer.focus.opacity};`);
    }
    if (stateLayer.disabled?.opacity !== undefined) {
      lines.push(`  --state-disabled-opacity: ${stateLayer.disabled.opacity};`);
    }

    // ========================================================================
    // Layer 2: Semantic Tokens
    // ========================================================================
    lines.push('');
    lines.push('  /* === Layer 2: Semantic Tokens === */');
    const { semantic } = theme.tokens;

    // Background
    if (semantic.background) {
      if (semantic.background.canvas) {
        lines.push(`  --bg-canvas: ${semantic.background.canvas};`);
      }
      if (semantic.background.surface) {
        for (const [name, value] of Object.entries(semantic.background.surface)) {
          lines.push(`  --bg-surface-${name}: ${value};`);
        }
      }
      if (semantic.background.elevated) {
        for (const [name, value] of Object.entries(semantic.background.elevated)) {
          lines.push(`  --bg-elevated-${name}: ${value};`);
        }
      }
    }

    // Foreground
    if (semantic.foreground) {
      if (semantic.foreground.primary) {
        for (const [name, value] of Object.entries(semantic.foreground.primary)) {
          lines.push(`  --fg-primary-${name}: ${value};`);
        }
      }
      if (semantic.foreground.secondary) {
        for (const [name, value] of Object.entries(semantic.foreground.secondary)) {
          lines.push(`  --fg-secondary-${name}: ${value};`);
        }
      }
      if (semantic.foreground.disabled) {
        lines.push(`  --fg-disabled: ${semantic.foreground.disabled};`);
      }
      if (semantic.foreground.placeholder) {
        lines.push(`  --fg-placeholder: ${semantic.foreground.placeholder};`);
      }
    }

    // Border
    if (semantic.border) {
      if (semantic.border.default) {
        for (const [name, value] of Object.entries(semantic.border.default)) {
          lines.push(`  --border-${name}: ${value};`);
        }
      }
      if (semantic.border.focus) {
        lines.push(`  --border-focus: ${semantic.border.focus};`);
      }
      if (semantic.border.error) {
        lines.push(`  --border-error: ${semantic.border.error};`);
      }
      if (semantic.border.success) {
        lines.push(`  --border-success: ${semantic.border.success};`);
      }
    }

    lines.push('}');

    // ========================================================================
    // Dark Mode (if present)
    // ========================================================================
    if (theme.darkMode?.tokens?.semantic) {
      lines.push('');
      lines.push('.dark {');
      lines.push('  /* === Dark Mode Overrides === */');

      const darkSemantic = theme.darkMode.tokens.semantic;
      if (darkSemantic.background?.canvas) {
        lines.push(`  --bg-canvas: ${darkSemantic.background.canvas};`);
      }
      if (darkSemantic.background?.surface) {
        for (const [name, value] of Object.entries(darkSemantic.background.surface)) {
          lines.push(`  --bg-surface-${name}: ${value};`);
        }
      }

      lines.push('}');
    }

    return {
      success: true,
      css: lines.join('\n'),
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error during CSS generation',
    };
  }
}

/**
 * 테마 ID로 CSS 생성
 *
 * @param themeId - 테마 ID
 * @returns CSS 생성 결과
 */
export function generateCSSFromThemeId(themeId: string): CSSGenerationResult {
  const theme = loadTheme(themeId);
  if (!theme) {
    return {
      success: false,
      error: `Theme not found: ${themeId}`,
    };
  }
  return generateCSS(theme);
}

/**
 * CSS Variables만 추출 (전체 CSS 대신)
 *
 * @param theme - ThemeV2 객체
 * @returns CSS Variables 객체 (key-value 쌍)
 */
export function extractCSSVariables(theme: ThemeV2): Record<string, string> {
  const result = generateCSS(theme);
  if (!result.success || !result.css) {
    return {};
  }

  const variables: Record<string, string> = {};
  const variableRegex = /--([\w-]+):\s*([^;]+);/g;
  let match;

  while ((match = variableRegex.exec(result.css)) !== null) {
    if (match[1] && match[2]) {
      variables[`--${match[1]}`] = match[2].trim();
    }
  }

  return variables;
}

// Re-export ThemeV2 type for convenience
export type { ThemeV2 };
